// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'board_direction.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$BoardDirectionTearOff {
  const _$BoardDirectionTearOff();

// ignore: unused_element
  _Right right() {
    return const _Right();
  }

// ignore: unused_element
  _Left left() {
    return const _Left();
  }

// ignore: unused_element
  _Down down() {
    return const _Down();
  }

// ignore: unused_element
  _Up up() {
    return const _Up();
  }
}

// ignore: unused_element
const $BoardDirection = _$BoardDirectionTearOff();

mixin _$BoardDirection {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result right(),
    @required Result left(),
    @required Result down(),
    @required Result up(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result right(),
    Result left(),
    Result down(),
    Result up(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result right(_Right value),
    @required Result left(_Left value),
    @required Result down(_Down value),
    @required Result up(_Up value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result right(_Right value),
    Result left(_Left value),
    Result down(_Down value),
    Result up(_Up value),
    @required Result orElse(),
  });
}

abstract class $BoardDirectionCopyWith<$Res> {
  factory $BoardDirectionCopyWith(
          BoardDirection value, $Res Function(BoardDirection) then) =
      _$BoardDirectionCopyWithImpl<$Res>;
}

class _$BoardDirectionCopyWithImpl<$Res>
    implements $BoardDirectionCopyWith<$Res> {
  _$BoardDirectionCopyWithImpl(this._value, this._then);

  final BoardDirection _value;
  // ignore: unused_field
  final $Res Function(BoardDirection) _then;
}

abstract class _$RightCopyWith<$Res> {
  factory _$RightCopyWith(_Right value, $Res Function(_Right) then) =
      __$RightCopyWithImpl<$Res>;
}

class __$RightCopyWithImpl<$Res> extends _$BoardDirectionCopyWithImpl<$Res>
    implements _$RightCopyWith<$Res> {
  __$RightCopyWithImpl(_Right _value, $Res Function(_Right) _then)
      : super(_value, (v) => _then(v as _Right));

  @override
  _Right get _value => super._value as _Right;
}

class _$_Right extends _Right {
  const _$_Right() : super._();

  @override
  String toString() {
    return 'BoardDirection.right()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Right);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result right(),
    @required Result left(),
    @required Result down(),
    @required Result up(),
  }) {
    assert(right != null);
    assert(left != null);
    assert(down != null);
    assert(up != null);
    return right();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result right(),
    Result left(),
    Result down(),
    Result up(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (right != null) {
      return right();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result right(_Right value),
    @required Result left(_Left value),
    @required Result down(_Down value),
    @required Result up(_Up value),
  }) {
    assert(right != null);
    assert(left != null);
    assert(down != null);
    assert(up != null);
    return right(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result right(_Right value),
    Result left(_Left value),
    Result down(_Down value),
    Result up(_Up value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (right != null) {
      return right(this);
    }
    return orElse();
  }
}

abstract class _Right extends BoardDirection {
  const _Right._() : super._();
  const factory _Right() = _$_Right;
}

abstract class _$LeftCopyWith<$Res> {
  factory _$LeftCopyWith(_Left value, $Res Function(_Left) then) =
      __$LeftCopyWithImpl<$Res>;
}

class __$LeftCopyWithImpl<$Res> extends _$BoardDirectionCopyWithImpl<$Res>
    implements _$LeftCopyWith<$Res> {
  __$LeftCopyWithImpl(_Left _value, $Res Function(_Left) _then)
      : super(_value, (v) => _then(v as _Left));

  @override
  _Left get _value => super._value as _Left;
}

class _$_Left extends _Left {
  const _$_Left() : super._();

  @override
  String toString() {
    return 'BoardDirection.left()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Left);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result right(),
    @required Result left(),
    @required Result down(),
    @required Result up(),
  }) {
    assert(right != null);
    assert(left != null);
    assert(down != null);
    assert(up != null);
    return left();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result right(),
    Result left(),
    Result down(),
    Result up(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (left != null) {
      return left();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result right(_Right value),
    @required Result left(_Left value),
    @required Result down(_Down value),
    @required Result up(_Up value),
  }) {
    assert(right != null);
    assert(left != null);
    assert(down != null);
    assert(up != null);
    return left(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result right(_Right value),
    Result left(_Left value),
    Result down(_Down value),
    Result up(_Up value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (left != null) {
      return left(this);
    }
    return orElse();
  }
}

abstract class _Left extends BoardDirection {
  const _Left._() : super._();
  const factory _Left() = _$_Left;
}

abstract class _$DownCopyWith<$Res> {
  factory _$DownCopyWith(_Down value, $Res Function(_Down) then) =
      __$DownCopyWithImpl<$Res>;
}

class __$DownCopyWithImpl<$Res> extends _$BoardDirectionCopyWithImpl<$Res>
    implements _$DownCopyWith<$Res> {
  __$DownCopyWithImpl(_Down _value, $Res Function(_Down) _then)
      : super(_value, (v) => _then(v as _Down));

  @override
  _Down get _value => super._value as _Down;
}

class _$_Down extends _Down {
  const _$_Down() : super._();

  @override
  String toString() {
    return 'BoardDirection.down()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Down);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result right(),
    @required Result left(),
    @required Result down(),
    @required Result up(),
  }) {
    assert(right != null);
    assert(left != null);
    assert(down != null);
    assert(up != null);
    return down();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result right(),
    Result left(),
    Result down(),
    Result up(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (down != null) {
      return down();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result right(_Right value),
    @required Result left(_Left value),
    @required Result down(_Down value),
    @required Result up(_Up value),
  }) {
    assert(right != null);
    assert(left != null);
    assert(down != null);
    assert(up != null);
    return down(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result right(_Right value),
    Result left(_Left value),
    Result down(_Down value),
    Result up(_Up value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (down != null) {
      return down(this);
    }
    return orElse();
  }
}

abstract class _Down extends BoardDirection {
  const _Down._() : super._();
  const factory _Down() = _$_Down;
}

abstract class _$UpCopyWith<$Res> {
  factory _$UpCopyWith(_Up value, $Res Function(_Up) then) =
      __$UpCopyWithImpl<$Res>;
}

class __$UpCopyWithImpl<$Res> extends _$BoardDirectionCopyWithImpl<$Res>
    implements _$UpCopyWith<$Res> {
  __$UpCopyWithImpl(_Up _value, $Res Function(_Up) _then)
      : super(_value, (v) => _then(v as _Up));

  @override
  _Up get _value => super._value as _Up;
}

class _$_Up extends _Up {
  const _$_Up() : super._();

  @override
  String toString() {
    return 'BoardDirection.up()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Up);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result right(),
    @required Result left(),
    @required Result down(),
    @required Result up(),
  }) {
    assert(right != null);
    assert(left != null);
    assert(down != null);
    assert(up != null);
    return up();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result right(),
    Result left(),
    Result down(),
    Result up(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (up != null) {
      return up();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result right(_Right value),
    @required Result left(_Left value),
    @required Result down(_Down value),
    @required Result up(_Up value),
  }) {
    assert(right != null);
    assert(left != null);
    assert(down != null);
    assert(up != null);
    return up(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result right(_Right value),
    Result left(_Left value),
    Result down(_Down value),
    Result up(_Up value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (up != null) {
      return up(this);
    }
    return orElse();
  }
}

abstract class _Up extends BoardDirection {
  const _Up._() : super._();
  const factory _Up() = _$_Up;
}
